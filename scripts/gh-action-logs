#!/usr/bin/env -S deno run --allow-run --allow-net=api.github.com

// @ts-ignore: Deno namespace
declare const Deno: {
  Command: new (cmd: string, options: { args: string[] }) => {
    output(): Promise<{ stdout: Uint8Array }>;
  };
  exit(code: number): never;
  args: string[];
};

const STATUS_EMOJI = {
  queued: "‚è≥",
  in_progress: "üîÑ",
  completed: "‚úÖ",
  failure: "‚ùå",
  cancelled: "‚ö´",
  skipped: "‚è≠Ô∏è",
  success: "‚úÖ",
  waiting: "‚åõ",
};

interface Run {
  databaseId: number;
  status: string;
  conclusion: string | null;
  headBranch: string;
  name: string;
  createdAt: string;
}

interface Job {
  id: number;
  status: string;
  conclusion: string | null;
  name: string;
}

function formatElapsedTime(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) {
    return `${seconds}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m${remainingSeconds}s`;
}

async function getRuns(watch = false): Promise<Run[]> {
  const process = new Deno.Command("gh", {
    args: [
      "run", 
      "list", 
      "-L", "10", 
      "--json", 
      "databaseId,status,conclusion,headBranch,name,createdAt"
    ],
  });
  const { stdout } = await process.output();
  let runs = JSON.parse(new TextDecoder().decode(stdout));
  
  if (watch) {
    // When watching, only show runs from last 10 minutes
    const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
    runs = runs.filter((run: Run) => new Date(run.createdAt) > tenMinutesAgo);
  }
  
  return runs;
}

async function getJobsForRun(runId: number): Promise<Job[]> {
  const process = new Deno.Command("gh", {
    args: ["api", `-X`, "GET", `/repos/mrkurt/ssh2wss/actions/runs/${runId}/jobs`, "--jq", ".jobs[]"],
  });
  const { stdout } = await process.output();
  return JSON.parse(`[${new TextDecoder().decode(stdout).split("\n").filter(Boolean).join(",")}]`);
}

async function getAnnotationsForJob(jobId: number): Promise<string[]> {
  const process = new Deno.Command("gh", {
    args: ["api", `-X`, "GET", `/repos/mrkurt/ssh2wss/check-runs/${jobId}/annotations`, "--jq", ".[].message"],
  });
  const { stdout } = await process.output();
  const text = new TextDecoder().decode(stdout).trim();
  return text ? text.split("\n") : [];
}

async function watchRun(run: Run): Promise<boolean> {
  // Use conclusion emoji for completed runs
  const emoji = run.status === "completed" && run.conclusion 
    ? STATUS_EMOJI[run.conclusion as keyof typeof STATUS_EMOJI] 
    : STATUS_EMOJI[run.status as keyof typeof STATUS_EMOJI];
  
  console.log(`${emoji} [${run.headBranch}] ${run.name} (#${run.databaseId})`);
  
  const jobs = await getJobsForRun(run.databaseId);
  for (const job of jobs) {
    // Use conclusion emoji for completed jobs
    const jobEmoji = job.status === "completed" && job.conclusion
      ? STATUS_EMOJI[job.conclusion as keyof typeof STATUS_EMOJI]
      : STATUS_EMOJI[job.status as keyof typeof STATUS_EMOJI];
      
    console.log(`  ${jobEmoji} ${job.name} (Job #${job.id})`);
    if (job.status === "completed") {
      const annotations = await getAnnotationsForJob(job.id);
      if (annotations.length > 0) {
        console.log("    Annotations:");
        for (const annotation of annotations) {
          console.log(`      - ${annotation}`);
        }
      }
    }
  }

  if (run.status === "completed") {
    const emoji = run.conclusion ? STATUS_EMOJI[run.conclusion as keyof typeof STATUS_EMOJI] : "‚ùì";
    console.log(`Run completed with conclusion: ${emoji} ${run.conclusion}`);
    return true;
  }
  return false;
}

async function waitForActiveRuns(): Promise<Run[]> {
  const startTime = Date.now();
  let lastUpdate = 0;
  let lastSeenRunId: number | null = null;

  while (true) {
    try {
      const runs = await getRuns(true);
      const activeRuns = runs.filter(run => {
        // Only show runs we haven't seen before
        if (lastSeenRunId === null) {
          lastSeenRunId = run.databaseId;
          return false;
        }
        return run.databaseId > lastSeenRunId;
      });
      
      if (activeRuns.length > 0) {
        lastSeenRunId = Math.max(...activeRuns.map(r => r.databaseId));
        return activeRuns;
      }

      // Update waiting message at most once per second
      const now = Date.now();
      if (now - lastUpdate >= 1000) {
        // Clear the previous line and write the new one
        // @ts-ignore: Deno namespace
        Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
        const message = `‚è≥ Waiting for runs... (${formatElapsedTime(now - startTime)})`;
        // @ts-ignore: Deno namespace
        Deno.stdout.writeSync(new TextEncoder().encode(message));
        lastUpdate = now;
      }

      await new Promise(resolve => setTimeout(resolve, 500));
    } catch (error) {
      console.error("\nError waiting for runs:", error.message);
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }
}

async function listRecentRuns(): Promise<void> {
  const runs = await getRuns(false);
  if (runs.length === 0) {
    console.log("No recent runs found");
    return;
  }

  for (const run of runs) {
    const emoji = run.conclusion ? STATUS_EMOJI[run.conclusion as keyof typeof STATUS_EMOJI] : "‚ùì";
    console.log(`${emoji} #${run.databaseId} [${run.headBranch}] ${run.name}`);
  }
}

async function main() {
  const watch = Deno.args.includes("--watch");

  try {
    if (watch) {
      while (true) {
        const activeRuns = await waitForActiveRuns();
        if (activeRuns.length === 0) {
          // Clear the waiting line before exiting
          // @ts-ignore: Deno namespace
          Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
          console.log("‚ú® No more active runs");
          return;
        }

        // Clear the waiting line before showing runs
        // @ts-ignore: Deno namespace
        Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
        console.log(`Found ${activeRuns.length} active run(s):`);
        
        // Watch all active runs
        for (const run of activeRuns) {
          await watchRun(run);
        }

        // Wait a bit before checking again
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    } else {
      await listRecentRuns();
    }
  } catch (error) {
    console.error("Fatal error:", error.message);
    // @ts-ignore: Deno namespace
    Deno.exit(1);
  }
}

// @ts-ignore: Deno import.meta
if (import.meta.main) {
  main();
} 