#!/usr/bin/env -S deno run --allow-run --allow-net=api.github.com --allow-write=tmp

const STATUS_EMOJI = {
  queued: "‚è≥",
  in_progress: "üîÑ",
  completed: "‚úÖ",
  failure: "‚ùå",
  cancelled: "‚ö´",
  skipped: "‚è≠Ô∏è",
  success: "‚úÖ",
  waiting: "‚åõ",
};

interface Run {
  databaseId: number;
  status: string;
  conclusion: string | null;
  headBranch: string;
  name: string;
  createdAt: string;
}

interface Job {
  id: number;
  status: string;
  conclusion: string | null;
  name: string;
}

function formatElapsedTime(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) {
    return `${seconds}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m${remainingSeconds}s`;
}

async function getRuns(watch = false): Promise<Run[]> {
  const process = new Deno.Command("gh", {
    args: [
      "run", 
      "list", 
      "-L", "10", 
      "--json", 
      "databaseId,status,conclusion,headBranch,name,createdAt"
    ],
  });
  const { stdout } = await process.output();
  let runs = JSON.parse(new TextDecoder().decode(stdout));
  
  if (watch) {
    // When watching, only show runs from last hour
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    runs = runs.filter((run: Run) => new Date(run.createdAt) > oneHourAgo);
  }
  
  return runs;
}

async function getJobsForRun(runId: number): Promise<Job[]> {
  const process = new Deno.Command("gh", {
    args: ["api", `-X`, "GET", `/repos/mrkurt/ssh2wss/actions/runs/${runId}/jobs`, "--jq", ".jobs[]"],
  });
  const { stdout } = await process.output();
  return JSON.parse(`[${new TextDecoder().decode(stdout).split("\n").filter(Boolean).join(",")}]`);
}

async function getAnnotationsForJob(jobId: number): Promise<string[]> {
  const process = new Deno.Command("gh", {
    args: ["api", `-X`, "GET", `/repos/mrkurt/ssh2wss/check-runs/${jobId}/annotations`, "--jq", ".[].message"],
  });
  const { stdout } = await process.output();
  const text = new TextDecoder().decode(stdout).trim();
  return text ? text.split("\n") : [];
}

// Command to dump all job logs for inspection:
// mkdir -p tmp && gh api repos/mrkurt/ssh2wss/actions/runs -q '.workflow_runs[].id' | while read run_id; do \
//   gh api "/repos/mrkurt/ssh2wss/actions/runs/$run_id/jobs" -q '.jobs[].id' | while read job_id; do \
//     gh api "/repos/mrkurt/ssh2wss/actions/jobs/$job_id/logs" > "tmp/action-logs-$job_id.txt" || true; \
//   done; \
// done

async function getJobLogs(jobId: number): Promise<string> {
  const process = new Deno.Command("gh", {
    args: ["api", `/repos/mrkurt/ssh2wss/actions/jobs/${jobId}/logs`],
    stderr: "piped",
  });
  const { stdout } = await process.output();
  const output = new TextDecoder().decode(stdout);
  
  if (Deno.args.includes("--show-all-logs")) {
    return output;
  }

  // Debug: show first few lines after timestamp removal
  console.log("\nFirst 10 cleaned lines:");
  output.split(/\r?\n/).slice(0, 10).forEach((line, i) => {
    const clean = stripTimestamps(line).replace(/\r$/, "");
    console.log(`Line ${i}:`, JSON.stringify(clean));
  });
  
  const chunks = extractErrorChunks(output);
  console.log("\nFound chunks:", chunks.length);
  if (chunks.length > 0) {
    console.log("First chunk preview:", JSON.stringify(chunks[0].slice(0, 200)));
  }
  
  return chunks.join("\n\n") || "No error logs found";
}

function stripTimestamps(line: string): string {
  const firstSpace = line.indexOf(" ");
  return firstSpace >= 0 ? line.slice(firstSpace + 1) : line;
}

function extractErrorChunks(logs: string): string[] {
  const lines = logs.split(/\r?\n/);
  const chunks: string[] = [];
  let currentChunk: string[] = [];
  let inGroup = false;
  let groupHasError = false;
  let indentLevel = 0;

  for (const line of lines) {
    const cleanLine = stripTimestamps(line).replace(/\r$/, "");
    
    // End chunk if we see Process completed, but include the line
    if (cleanLine.includes("Process completed")) {
      if (groupHasError) {
        currentChunk.push(`${" ".repeat(indentLevel * 2)}\x1b[31m${cleanLine.replace(/##\[error\]\s*/, "")}\x1b[0m`);
        chunks.push(currentChunk.join("\n"));
      }
      currentChunk = [];
      groupHasError = false;
      inGroup = false;
      indentLevel = 0;
      continue;
    }
    
    if (cleanLine.startsWith("##[group]")) {
      // Save previous chunk if it had errors
      if (groupHasError) {
        chunks.push(currentChunk.join("\n"));
      }
      // Start new chunk if it's a Run group
      if (cleanLine.startsWith("##[group]Run")) {
        currentChunk = [cleanLine.replace(/##\[group\]\s*/, "")];
        groupHasError = false;
      }
      inGroup = true;
      indentLevel++;
      continue;
    }

    if (cleanLine.startsWith("##[endgroup]")) {
      indentLevel = Math.max(0, indentLevel - 1);
      inGroup = indentLevel > 0;
      continue;
    }

    if (cleanLine.includes("##[error]")) {
      groupHasError = true;
      // Color errors in red and strip error token
      currentChunk.push(`${" ".repeat(indentLevel * 2)}\x1b[31m${cleanLine.replace(/##\[error\]\s*/, "")}\x1b[0m`);
    } else if (inGroup) {
      // Indent non-group-marker lines when in a group
      currentChunk.push(`${" ".repeat(indentLevel * 2)}${cleanLine}`);
    } else {
      currentChunk.push(cleanLine);
    }
  }

  // Don't forget the last chunk if we haven't seen Process completed
  if (groupHasError) {
    chunks.push(currentChunk.join("\n"));
  }

  return chunks;
}

async function watchRun(run: Run): Promise<boolean> {
  const showAnnotations = Deno.args.includes("--show-annotations");
  
  // Use conclusion emoji for completed runs
  const emoji = run.status === "completed" && run.conclusion 
    ? STATUS_EMOJI[run.conclusion as keyof typeof STATUS_EMOJI] 
    : STATUS_EMOJI[run.status as keyof typeof STATUS_EMOJI];
  
  console.log(`${emoji} [${run.headBranch}] ${run.name} (#${run.databaseId})`);
  
  const jobs = await getJobsForRun(run.databaseId);
  for (const job of jobs) {
    // Use conclusion emoji for completed jobs
    const jobEmoji = job.status === "completed" && job.conclusion
      ? STATUS_EMOJI[job.conclusion as keyof typeof STATUS_EMOJI]
      : STATUS_EMOJI[job.status as keyof typeof STATUS_EMOJI];
      
    console.log(`  ${jobEmoji} ${job.name} (Job #${job.id})`);
    if (job.status === "completed") {
      if (showAnnotations) {
        const annotations = await getAnnotationsForJob(job.id);
        if (annotations.length > 0) {
          console.log("    Annotations:");
          for (const annotation of annotations) {
            console.log(`      - ${annotation}`);
          }
        }
      }
      
      // Show full logs for failed jobs
      if (job.conclusion === "failure") {
        console.log("\n    Full job logs:");
        const logs = await getJobLogs(job.id);
        console.log(logs.split("\n").map(line => `      ${line}`).join("\n"));
      }
    }
  }

  if (run.status === "completed") {
    const emoji = run.conclusion ? STATUS_EMOJI[run.conclusion as keyof typeof STATUS_EMOJI] : "‚ùì";
    console.log(`Run completed with conclusion: ${emoji} ${run.conclusion}`);
    return true;
  }
  return false;
}

async function waitForActiveRuns(): Promise<Run[]> {
  const startTime = Date.now();
  let lastUpdate = 0;
  let lastSeenRunId: number | null = null;

  while (true) {
    try {
      const runs = await getRuns(true);
      const activeRuns = runs.filter(run => {
        // Only show runs we haven't seen before
        if (lastSeenRunId === null) {
          lastSeenRunId = run.databaseId;
          return false;
        }
        return run.databaseId > lastSeenRunId;
      });
      
      if (activeRuns.length > 0) {
        lastSeenRunId = Math.max(...activeRuns.map(r => r.databaseId));
        return activeRuns;
      }

      // Update waiting message at most once per second
      const now = Date.now();
      if (now - lastUpdate >= 1000) {
        // Clear the previous line and write the new one
        Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
        const message = `‚è≥ Waiting for runs... (${formatElapsedTime(now - startTime)})`;
        Deno.stdout.writeSync(new TextEncoder().encode(message));
        lastUpdate = now;
      }

      await new Promise(resolve => setTimeout(resolve, 500));
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      console.error("\nError waiting for runs:", message);
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }
}

async function listRecentRuns(): Promise<void> {
  const runs = await getRuns(false);
  if (runs.length === 0) {
    console.log("No recent runs found");
    return;
  }

  // Find most recent failed run
  const recentFailedRun = runs.find(run => run.conclusion === "failure");
  if (recentFailedRun) {
    console.log("Most recent failed run:");
    await watchRun(recentFailedRun);
    // Exit if this run is already completed and failed
    if (recentFailedRun.status === "completed" && recentFailedRun.conclusion === "failure") {
      console.log("Exiting due to failed run");
      Deno.exit(0);
    }
    console.log("\nNow watching for new runs...");
  } else {
    console.log("No failed runs found in recent history");
  }
}

async function actionLogsMain() {
  const watch = Deno.args.includes("--watch");

  try {
    if (watch) {
      // Show recent failed or in-progress runs from last hour
      const runs = await getRuns(true);
      const recentRuns = runs.filter(run => 
        run.conclusion === "failure" || 
        run.status === "in_progress" ||
        run.status === "queued"
      );

      if (recentRuns.length > 0) {
        console.log("Recent runs:");
        for (const run of recentRuns) {
          await watchRun(run);
          // Exit if this run is completed and failed
          if (run.status === "completed" && run.conclusion === "failure") {
            console.log("Exiting due to failed run");
            Deno.exit(0);
          }
        }
        console.log("\nNow watching for new runs...");
      }

      while (true) {
        const activeRuns = await waitForActiveRuns();
        if (activeRuns.length === 0) {
          // Clear the waiting line before exiting
          Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
          console.log("‚ú® No more active runs");
          return;
        }

        // Clear the waiting line before showing runs
        Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
        console.log(`Found ${activeRuns.length} active run(s):`);
        
        // Watch all active runs
        for (const run of activeRuns) {
          await watchRun(run);
          // Exit if this run failed
          if (run.status === "completed" && run.conclusion === "failure") {
            console.log("Exiting due to failed run");
            Deno.exit(0);
          }
        }

        // Wait a bit before checking again
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    } else {
      await listRecentRuns();
    }
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    console.error("Fatal error:", message);
    Deno.exit(1);
  }
}

if (import.meta.main) {
  actionLogsMain();
} 