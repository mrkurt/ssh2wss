#!/usr/bin/env -S deno run --allow-run --allow-net=api.github.com

// IMPORTANT: Always make the smallest possible changes to this file when modifying it.
// Each change should be focused and minimal to maintain stability and readability.

const STATUS_EMOJI = {
  queued: "‚è≥",
  in_progress: "üîÑ",
  completed: "‚úÖ",
  failure: "‚ùå",
  cancelled: "‚ö´",
  skipped: "‚è≠Ô∏è",
  success: "‚úÖ",
  waiting: "‚åõ",
};

interface Run {
  databaseId: number;
  status: string;
  conclusion: string | null;
  headBranch: string;
  name: string;
  createdAt: string;
  head_sha: string;
}

interface Job {
  databaseId: number;
  name: string;
  status: string;
  conclusion: string | null;
}

function formatElapsedTime(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) {
    return `${seconds}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m${remainingSeconds}s`;
}

async function getCurrentCommitSHA(): Promise<string> {
  const process = new Deno.Command("git", {
    args: ["rev-parse", "HEAD"],
  });
  const { stdout } = await process.output();
  return new TextDecoder().decode(stdout).trim();
}

async function getRuns(watch = false): Promise<Run[]> {
  const process = new Deno.Command("gh", {
    args: ["api", "/repos/mrkurt/ssh2wss/actions/runs"],
  });
  const { stdout } = await process.output();
  const response = JSON.parse(new TextDecoder().decode(stdout));
  let runs = response.workflow_runs.map((run: any) => ({
    databaseId: run.id,
    status: run.status,
    conclusion: run.conclusion,
    headBranch: run.head_branch,
    name: run.name || run.workflow_name,
    createdAt: run.created_at,
    head_sha: run.head_sha
  }));
  
  if (watch) {
    // When watching, only show runs from last hour
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    runs = runs.filter((run: Run) => new Date(run.createdAt) > oneHourAgo);
  }
  
  return runs;
}

async function getJobsForRun(runId: number): Promise<Job[]> {
  const process = new Deno.Command("gh", {
    args: ["api", `-X`, "GET", `/repos/mrkurt/ssh2wss/actions/runs/${runId}/jobs`, "--jq", ".jobs[]"],
  });
  const { stdout } = await process.output();
  return JSON.parse(`[${new TextDecoder().decode(stdout).split("\n").filter(Boolean).join(",")}]`);
}

async function getAnnotationsForJob(jobId: number): Promise<string[]> {
  const process = new Deno.Command("gh", {
    args: ["api", `-X`, "GET", `/repos/mrkurt/ssh2wss/check-runs/${jobId}/annotations`, "--jq", ".[].message"],
  });
  const { stdout } = await process.output();
  const text = new TextDecoder().decode(stdout).trim();
  return text ? text.split("\n") : [];
}

// NEVER change this timestamp splitting logic without confirmation!
// GitHub Actions timestamps are always followed by a single space, so we split at the first space
function stripTimestamps(line: string): string {
  const spaceIndex = line.indexOf(" ");
  return spaceIndex >= 0 ? line.slice(spaceIndex + 1) : line;
}

function formatLine(line: string): string {
  // Don't recolor if line already has color codes
  if (line.includes("\u001b[")) {
    return line;
  }

  if (line.startsWith("##[command]")) {
    // Remove ##[command] prefix and color yellow
    const cmd = line.slice("##[command]".length).trim();
    return `\u001b[33m${cmd}\u001b[0m`;
  } else if (line.startsWith("##[error]")) {
    // Remove ##[error] prefix and color red
    const error = line.slice("##[error]".length).trim();
    return `\u001b[31m${error}\u001b[0m`;
  }
  return line;
}

function extractErrorChunks(logs: string): string[] {
  const lines = logs.split(/\r?\n/);
  const chunks: string[] = [];
  let currentChunk: string[] = [];
  let inErrorGroup = false;
  let hasError = false;

  for (const line of lines) {
    const cleanLine = stripTimestamps(line);
    const formattedLine = formatLine(cleanLine);

    if (cleanLine.includes('##[group]')) {
      if (currentChunk.length > 0 && hasError) {
        chunks.push(currentChunk.join('\n'));
      }
      currentChunk = [formattedLine];
      inErrorGroup = true;
      hasError = false;
    } else if (cleanLine.includes('##[error]') || cleanLine.includes('FAIL') || cleanLine.includes('error:')) {
      hasError = true;
      currentChunk.push(formattedLine);
      // End chunk if this is a Process completed error
      if (cleanLine.includes('##[error]Process completed')) {
        chunks.push(currentChunk.join('\n'));
        currentChunk = [];
        inErrorGroup = false;
        hasError = false;
      }
    } else if (cleanLine.includes('##[endgroup]')) {
      inErrorGroup = false;
      currentChunk.push(formattedLine);
      if (hasError) {
        chunks.push(currentChunk.join('\n'));
        currentChunk = [];
      }
    } else if (inErrorGroup || hasError) {
      currentChunk.push(formattedLine);
    }
  }

  if (currentChunk.length > 0 && hasError) {
    chunks.push(currentChunk.join('\n'));
  }

  return chunks;
}

async function getJobLogs(jobId: number): Promise<string> {
  const process = new Deno.Command("gh", {
    args: ["api", `/repos/mrkurt/ssh2wss/actions/jobs/${jobId}/logs`],
    stderr: "piped",
  });
  const { stdout } = await process.output();
  const output = new TextDecoder().decode(stdout);
  
  if (Deno.args.includes("--show-all-logs")) {
    return output;
  }

  const chunks = extractErrorChunks(output);
  return chunks.length > 0 ? chunks.join("\n\n") : "...";
}

async function watchRun(run: Run): Promise<boolean> {
  const showAnnotations = Deno.args.includes("--show-annotations");
  
  // Save cursor position for next update
  let numLines = 0;
  
  // Helper to count lines in a string
  function countLines(str: string): number {
    return str.split("\n").length;
  }
  
  // Move cursor up and clear lines
  function clearPreviousOutput() {
    if (numLines > 0) {
      // Move up N lines and clear to bottom of screen
      console.log(`\x1b[${numLines}A\x1b[J`);
    }
  }
  
  // Use conclusion emoji for completed runs
  const emoji = run.status === "completed" && run.conclusion 
    ? STATUS_EMOJI[run.conclusion as keyof typeof STATUS_EMOJI] 
    : STATUS_EMOJI[run.status as keyof typeof STATUS_EMOJI];
  
  clearPreviousOutput();
  let output = `${emoji} [${run.headBranch}] ${run.name} (#${run.databaseId})\n`;
  numLines = 1;
  
  const jobs = await getJobsForRun(run.databaseId);
  for (const job of jobs) {
    // Use conclusion emoji for completed jobs
    const jobEmoji = job.status === "completed" && job.conclusion
      ? STATUS_EMOJI[job.conclusion as keyof typeof STATUS_EMOJI]
      : STATUS_EMOJI[job.status as keyof typeof STATUS_EMOJI];
      
    output += `  ${jobEmoji} ${job.name} (Job #${job.databaseId})\n`;
    numLines++;
    
    if (job.status === "completed") {
      if (showAnnotations) {
        const annotations = await getAnnotationsForJob(job.databaseId);
        if (annotations.length > 0) {
          output += "    Annotations:\n";
          numLines++;
          for (const annotation of annotations) {
            output += `      - ${annotation}\n`;
            numLines++;
          }
        }
      }
      
      // Show full logs for failed jobs
      if (job.conclusion === "failure") {
        output += "\n    Full job logs:\n";
        numLines += 2;
        const logs = await getJobLogs(job.databaseId);
        const logLines = logs.split("\n").map(line => `      ${line}`).join("\n");
        output += logLines + "\n";
        numLines += countLines(logLines) + 1;
      }
    } else if (job.status === "in_progress") {
      // Show current logs for in-progress jobs
      output += "\n    Current job logs:\n";
      numLines += 2;
      const logs = await getJobLogs(job.databaseId);
      const logLines = logs.split("\n").map(line => `      ${line}`).join("\n");
      output += logLines + "\n";
      numLines += countLines(logLines) + 1;
    }
  }

  if (run.status === "completed") {
    const emoji = run.conclusion ? STATUS_EMOJI[run.conclusion as keyof typeof STATUS_EMOJI] : "‚ùì";
    output += `Run completed with conclusion: ${emoji} ${run.conclusion}\n`;
    numLines++;
  }
  
  console.log(output);
  return run.status === "completed";
}

async function waitForRunWithCommit(sha: string): Promise<Run | null> {
  const startTime = Date.now();
  let lastUpdate = 0;

  while (true) {
    try {
      const runs = await getRuns(true);
      const run = runs.find(r => r.head_sha === sha);
      if (run) return run;

      // Update waiting message at most once per second
      const now = Date.now();
      if (now - lastUpdate >= 1000) {
        // Clear the previous line and write the new one
        Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
        const message = `‚è≥ Waiting for run with commit ${sha.slice(0, 7)}... (${formatElapsedTime(now - startTime)})`;
        Deno.stdout.writeSync(new TextEncoder().encode(message));
        lastUpdate = now;
      }

      await new Promise(resolve => setTimeout(resolve, 2000));
    } catch (error) {
      console.error("\nError waiting for run:", error);
      return null;
    }
  }
}

async function listRecentRuns(): Promise<void> {
  const sha = await getCurrentCommitSHA();
  const runs = await getRuns(false);
  if (runs.length === 0) {
    console.log("No recent runs found");
    return;
  }

  // First try to find run for current commit
  const currentRun = runs.find(run => run.head_sha === sha);
  if (currentRun) {
    console.log("Found run for current commit:");
    await watchRun(currentRun);
    return;
  }

  // If no run for current commit, find most recent failed run
  const recentFailedRun = runs.find(run => run.conclusion === "failure");
  if (recentFailedRun) {
    console.log("Most recent failed run:");
    await watchRun(recentFailedRun);
  } else {
    console.log("No failed runs found in recent history");
  }
}

async function saveRawLogs(runId: number, jobId: number) {
  const cmd = new Deno.Command("gh", {
    args: ["api", `/repos/mrkurt/ssh2wss/actions/jobs/${jobId}/logs`],
  });
  const output = await cmd.output();
  const logs = new TextDecoder().decode(output.stdout);
  
  const tmpFile = await Deno.makeTempFile({ prefix: "gh-action-", suffix: ".log" });
  await Deno.writeTextFile(tmpFile, logs);
  console.log(`Raw logs saved to: ${tmpFile}`);
  return logs;
}

async function findLatestRun(): Promise<Run | null> {
  const cmd = new Deno.Command("gh", {
    args: ["api", "/repos/mrkurt/ssh2wss/actions/runs"],
  });
  const output = await cmd.output();
  const response = JSON.parse(new TextDecoder().decode(output.stdout));
  const runs = response.workflow_runs;
  return runs.length > 0 ? runs[0] : null;
}

async function processJobLogs(job: Job, showAllLogs: boolean) {
  const logs = await getJobLogs(job.databaseId);
  if (showAllLogs) {
    console.log(logs);
  } else {
    const chunks = extractErrorChunks(logs);
    if (chunks.length === 0) {
      console.log("No error logs found");
    } else {
      chunks.forEach((chunk, i) => {
        console.log(`\nError chunk ${i + 1}:`);
        console.log(chunk);
      });
    }
  }
}

async function actionLogsMain() {
  const args = Deno.args;
  const shouldWatch = args.includes("--watch");
  const showAllLogs = args.includes("--showAllLogs");
  const saveRaw = args.includes("--save-raw");

  try {
    if (shouldWatch) {
      const sha = await getCurrentCommitSHA();
      console.log("Watching for workflow run with commit:", sha);
      await watchRun(sha);
      return;
    }

    const run = await findLatestRun();
    if (!run) {
      console.error("No workflow run found");
      Deno.exit(1);
    }

    if (saveRaw) {
      const jobs = await getJobsForRun(run.databaseId);
      await saveRawLogs(run.databaseId, jobs[0].databaseId);
    } else {
      const jobs = await getJobsForRun(run.databaseId);
      await processJobLogs(jobs[0], showAllLogs);
    }
  } catch (error) {
    console.error("Fatal error:", error);
    Deno.exit(1);
  }
}

if (import.meta.main) {
  actionLogsMain();
}