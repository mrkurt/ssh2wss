#!/usr/bin/env -S deno run --allow-run

// @ts-ignore: Deno module resolution
import { Command } from "https://deno.land/std@0.217.0/cli/mod.ts";

interface RunInfo {
  databaseId: string;
  status: string;
  conclusion: string | null;
  name: string;
  createdAt: string;
  headBranch: string;
}

const STATUS_EMOJI = {
  queued: "‚è≥",
  in_progress: "üèÉ",
  completed: "‚úÖ",
  failure: "‚ùå",
  success: "‚ú®",
  cancelled: "üö´",
  skipped: "‚è≠Ô∏è",
} as const;

function formatElapsedTime(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) {
    return `${seconds}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m${remainingSeconds}s`;
}

async function getActiveRuns(): Promise<RunInfo[]> {
  // @ts-ignore: Deno namespace
  const process = new Deno.Command("gh", {
    args: [
      "run", 
      "list", 
      "-L", "10", 
      "--json", "databaseId,status,conclusion,name,createdAt,headBranch",
    ],
    stderr: "piped",
  });
  const { stdout, stderr } = await process.output();
  const stderrText = new TextDecoder().decode(stderr);
  if (stderrText) {
    console.error("Error fetching runs:", stderrText);
    // @ts-ignore: Deno namespace
    Deno.exit(1);
    return []; // Unreachable but satisfies TypeScript
  }
  
  const stdoutText = new TextDecoder().decode(stdout).trim();
  if (!stdoutText) {
    return [];
  }
  
  try {
    return JSON.parse(stdoutText);
  } catch (error) {
    console.error("Failed to parse GitHub response:");
    console.error("Raw output:", stdoutText);
    console.error("Parse error:", error.message);
    // @ts-ignore: Deno namespace
    Deno.exit(1);
    return []; // Unreachable but satisfies TypeScript
  }
}

async function getRunLogs(runId: string): Promise<void> {
  // @ts-ignore: Deno namespace
  const process = new Deno.Command("gh", {
    args: ["run", "view", runId, "--log"],
    stdout: "piped",
    stderr: "piped",
  });
  const { stdout, stderr } = await process.output();
  const output = new TextDecoder().decode(stdout);
  const errors = new TextDecoder().decode(stderr);
  
  if (errors) {
    console.error("Error fetching logs:", errors);
  }
  
  if (!output && !errors) {
    console.log("No logs available yet");
    return;
  }
  
  // Look for test failures
  const lines = [...output.split("\n"), ...errors.split("\n")];
  for (const line of lines) {
    if (line.includes("FAIL") || line.includes("Error:") || line.includes("tput: No value for $TERM")) {
      console.log(line);
    }
  }
}

async function watchRun(run: RunInfo): Promise<void> {
  let lastStatus = run.status;
  console.log(`${STATUS_EMOJI[run.status as keyof typeof STATUS_EMOJI]} [${run.headBranch}] ${run.name} (#${run.databaseId})`);
  
  while (true) {
    try {
      // @ts-ignore: Deno namespace
      const process = new Deno.Command("gh", {
        args: ["run", "view", run.databaseId, "--json", "status,conclusion", "-q", "."],
        stderr: "piped",
      });
      const { stdout, stderr } = await process.output();
      const stderrText = new TextDecoder().decode(stderr);
      if (stderrText) {
        console.error("Error checking run status:", stderrText);
        break;
      }
      
      const stdoutText = new TextDecoder().decode(stdout).trim();
      if (!stdoutText) {
        console.error("Empty response when checking run status");
        break;
      }
      
      const result = JSON.parse(stdoutText);
      
      if (result.status !== lastStatus) {
        const emoji = STATUS_EMOJI[result.status as keyof typeof STATUS_EMOJI] || "‚ùì";
        console.log(`${emoji} [${run.headBranch}] ${result.status} (#${run.databaseId})`);
        lastStatus = result.status;
        
        if (result.status === "completed") {
          const conclusionEmoji = STATUS_EMOJI[result.conclusion as keyof typeof STATUS_EMOJI] || "‚ùì";
          console.log(`${conclusionEmoji} [${run.headBranch}] Conclusion: ${result.conclusion} (#${run.databaseId})`);
          if (result.conclusion !== "success") {
            await getRunLogs(run.databaseId);
          }
          break;
        }
      }
    } catch (error) {
      console.error("Error watching run:", error.message);
      break;
    }
    
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
}

async function waitForActiveRuns(): Promise<RunInfo[]> {
  const startTime = Date.now();
  let lastUpdate = 0;
  let hasSeenRun = false;

  while (true) {
    try {
      const runs = await getActiveRuns();
      const activeRuns = runs.filter(run => run.status !== "completed");
      
      if (activeRuns.length > 0) {
        hasSeenRun = true;
        return activeRuns;
      }

      // If we've seen a run before but now there are none, we can exit
      if (hasSeenRun) {
        return [];
      }

      // Update waiting message at most once per second
      const now = Date.now();
      if (now - lastUpdate >= 1000) {
        // Clear the previous line and write the new one
        // @ts-ignore: Deno namespace
        Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
        const message = `‚è≥ Waiting for runs... (${formatElapsedTime(now - startTime)})`;
        // @ts-ignore: Deno namespace
        Deno.stdout.writeSync(new TextEncoder().encode(message));
        lastUpdate = now;
      }

      await new Promise(resolve => setTimeout(resolve, 500));
    } catch (error) {
      console.error("\nError waiting for runs:", error.message);
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }
}

async function main() {
  try {
    const activeRuns = await waitForActiveRuns();
    if (activeRuns.length === 0) {
      // Clear the waiting line before exiting
      // @ts-ignore: Deno namespace
      Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
      console.log("‚ú® No more active runs");
      return;
    }

    // Clear the waiting line before showing runs
    // @ts-ignore: Deno namespace
    Deno.stdout.writeSync(new TextEncoder().encode("\r\x1b[K"));
    console.log(`Found ${activeRuns.length} active run(s):`);
    
    // Watch all active runs concurrently
    await Promise.all(activeRuns.map(run => watchRun(run)));
  } catch (error) {
    console.error("Fatal error:", error.message);
    // @ts-ignore: Deno namespace
    Deno.exit(1);
  }
}

// @ts-ignore: Deno import.meta
if (import.meta.main) {
  main();
} 