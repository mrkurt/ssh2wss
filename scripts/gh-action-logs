#!/usr/bin/env -S deno run --allow-run

// @ts-ignore: Deno module resolution
import { Command } from "https://deno.land/std@0.217.0/cli/mod.ts";

interface RunInfo {
  databaseId: string;
  status: string;
  conclusion: string | null;
  displayTitle: string;
  createdAt: string;
  headBranch: string;
}

const STATUS_EMOJI = {
  queued: "‚è≥",
  in_progress: "üèÉ",
  completed: "‚úÖ",
  failure: "‚ùå",
  success: "‚ú®",
  cancelled: "üö´",
  skipped: "‚è≠Ô∏è",
} as const;

async function getActiveRuns(): Promise<RunInfo[]> {
  // @ts-ignore: Deno namespace
  const process = new Deno.Command("gh", {
    args: [
      "run", 
      "list", 
      "-L", "10", 
      "--json", "databaseId,status,conclusion,displayTitle,createdAt,headBranch",
    ],
  });
  const { stdout } = await process.output();
  return JSON.parse(new TextDecoder().decode(stdout).trim());
}

async function getRunLogs(runId: string): Promise<void> {
  // @ts-ignore: Deno namespace
  const process = new Deno.Command("gh", {
    args: ["run", "view", runId, "--log"],
    stdout: "piped",
    stderr: "piped",
  });
  const { stdout, stderr } = await process.output();
  const output = new TextDecoder().decode(stdout);
  const errors = new TextDecoder().decode(stderr);
  
  // Look for test failures
  const lines = [...output.split("\n"), ...errors.split("\n")];
  for (const line of lines) {
    if (line.includes("FAIL") || line.includes("Error:") || line.includes("tput: No value for $TERM")) {
      console.log(line);
    }
  }
}

async function watchRun(run: RunInfo): Promise<void> {
  let lastStatus = run.status;
  console.log(`${STATUS_EMOJI[run.status as keyof typeof STATUS_EMOJI]} [${run.headBranch}] ${run.displayTitle}`);
  
  while (true) {
    // @ts-ignore: Deno namespace
    const process = new Deno.Command("gh", {
      args: ["run", "view", run.databaseId, "--json", "status,conclusion", "-q", "."],
    });
    const { stdout } = await process.output();
    const result = JSON.parse(new TextDecoder().decode(stdout));
    
    if (result.status !== lastStatus) {
      const emoji = STATUS_EMOJI[result.status as keyof typeof STATUS_EMOJI] || "‚ùì";
      console.log(`${emoji} [${run.headBranch}] ${result.status}`);
      lastStatus = result.status;
      
      if (result.status === "completed") {
        const conclusionEmoji = STATUS_EMOJI[result.conclusion as keyof typeof STATUS_EMOJI] || "‚ùì";
        console.log(`${conclusionEmoji} [${run.headBranch}] Conclusion: ${result.conclusion}`);
        if (result.conclusion !== "success") {
          await getRunLogs(run.databaseId);
        }
        break;
      }
    }
    
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
}

async function waitForActiveRuns(): Promise<RunInfo[]> {
  while (true) {
    const runs = await getActiveRuns();
    const activeRuns = runs.filter(run => run.status !== "completed");
    if (activeRuns.length > 0) {
      return activeRuns;
    }
    console.log("‚è≥ Waiting for active runs...");
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
}

async function main() {
  try {
    const activeRuns = await waitForActiveRuns();
    console.log(`Found ${activeRuns.length} active run(s):`);
    
    // Watch all active runs concurrently
    await Promise.all(activeRuns.map(run => watchRun(run)));
  } catch (error) {
    console.error("Error:", error.message);
    // @ts-ignore: Deno namespace
    Deno.exit(1);
  }
}

// @ts-ignore: Deno import.meta
if (import.meta.main) {
  main();
} 